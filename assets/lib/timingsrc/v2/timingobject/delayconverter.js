/*
Copyright 2015 Norut Northern Research Institute
Author : Ingar MÃ¦hlum Arntzen

This file is part of the Timingsrc module.

Timingsrc is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Timingsrc is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
DELAY CONVERTER

Delay Converter introduces a positive time delay on a source timing object.

Generally - if the source timing object has some value at time t, 
then the delayConverter will provide the same value at time t + delay.

Since the delay Converter is effectively replaying past events after the fact,
it is not LIVE and not open to interactivity (i.e. update)

*/

import timingobject from './timingobject';

var TimingObjectBase = timingobject.TimingObjectBase;	
var inherit = TimingObjectBase.inherit;

var DelayConverter = function (timingObject, delay) {
	if (!(this instanceof DelayConverter)) {
		throw new Error("Contructor function called without new operation");
	}
	if (delay < 0) {throw new Error ("negative delay not supported");}
	if (delay === 0) {throw new Error ("zero delay makes delayconverter pointless");}
	TimingObjectBase.call(this, timingObject);
	// fixed delay
	this._delay = delay;
};
inherit(DelayConverter, TimingObjectBase);

// overrides
DelayConverter.prototype.onVectorChange = function (vector) {
	/* 			
		Vector's timestamp always time-shifted (back-dated) by delay

		Normal operation is to delay every incoming vector update.
		This implies returning null to abort further processing at this time,
		and instead trigger a later continuation.

		However, delay is calculated based on the timestamp of the vector (age), not when the vector is 
		processed in this method. So, for small small delays the age of the vector could already be
		greater than delay, indicating that the vector is immediately valid and do not require delayed processing.

		This is particularly true for the first vector, which may be old. 

		So we generally check the age to figure out whether to apply the vector immediately or to delay it.
	*/

	// age of incoming vector
	var age = this.clock.now() - vector.timestamp;
	
	// time-shift vector timestamp
	vector.timestamp += this._delay;

	if (age < this._delay) {
		// apply vector later - abort processing now
		var self = this;
		var delayMillis = (this._delay - age) * 1000;
		setTimeout(function () {
			self._process(vector);
		}, delayMillis);	
		return null;
	}
	// apply vector immediately - continue processing
	return vector;
};

DelayConverter.prototype.update = function (vector) {
	// Updates are prohibited on delayed timingobjects
	throw new Error ("update is not legal on delayed (non-live) timingobject");
};

export default DelayConverter;
